1.Cache là gì?
- cache là một cơ chế mà ở đó các dữ liệu được lấy lên từ database  hay từ một
  nguồn dữ liệu nào đó và được lưu vào memory, do đặc tính của memory là truy xuất
  tức thời nên việc sử dụng cache sẽ làm cho hệ thống nhanh hơn,
  giảm được thời gian truy xuất xuống DB hoặc gọi tới API khác để lấy dữ liệu
- Có 3 kiểu bộ nhớ cache trong Hibernate đó là: Bộ nhớ cache cấp một (First-level), 
  Bộ nhớ cache cấp hai (Second-level) và Bộ nhớ cache cấp truy vấn.
  
- First Level Cache được kết hợp với đối tượng "session"  
- Phạm vi của cách đối tượng cache này là session (phiên). 
  Khi một session bị đóng lại, các đối tượng cache thuộc session đó sẽ vĩnh viễn bị mất đi  
  
*Second Level Cache 
- phạm vi ảnh hưởng của First Level Cache(L1) là nội session. Nghĩa là khi bạn gọi đối tượng X trong sessionA, 
thì nó sẽ chỉ tìm đối tượng X trong sessionA và trong trường hợp sessionA không có, nó sẽ thực thi câu lệnh truy vấn tới DB. 
- Khác với L1, phạm vi lưu trữ đối tượng được mở rộng hơn trong L2, sang mức SessionFactory thay vì session như L1

Để bật Second Level Cache trong Hibernate, bạn chỉ cần cấu hình 2 thuộc tính : 
	- hibernate.cache.use_second_level_cache = true
	- hibernate.cache.region.factory_class = org.hibernate.cache.ehcache.SingletonEhCacheRegionFactory 
		để chỉ định tên lớp Region Factory
		
*Querry Level Cache 		
- Để sử dụng bộ nhớ cache truy vấn, trước tiên bạn phải kích hoạt nó bằng cách sử dụng thuộc tính 
	hibernate.cache.use_query_cache = "true"		

* Cache Concurrency Strategy
- READ_ONLY: Chỉ được sử dụng cho các thực thể được đọc thường xuyên nhưng không bao giờ bị thay đổi
- READ_WRITE: Cơ chế này đảm bảo tính nhất quán dữ liệu cao bằng việc sử dụng 'soft lock`. 
			  Khi một thực thể đã được cache bị update, một 'soft lock' được lưu lại trong cache cho entity 
			  và nó sẽ được giải phóng (release) khi transaction được commit. Tất cả các transaction nếu 
			  truy cập vào các đối tượng đang bị softblock sẽ được lấy trực tiếp từ cơ sở dữ liệu. 
			  Bạn hình dung là, nếu 1 TRANSACTION A đang muốn update đối tượng X, thì nó sẽ "khóa" đối tượng X
			  lại và khi các TRANSACTION B, C muốn sử dụng đối tượng X, nó sẽ phải lấy trực tiếp từ DB thay vì từ 
			  cache cho đến khi nào TRANSACTION A mở khóa cho đối tượng X (như mình vừa nói là sau khi transaction commit)
- TRANSACTIONAL: Cơ chế này đảm bảo các transaction làm việc biệt lập hoàn toàn
- NONSTRICT_READ_WRITE: Cơ chế này không đảm bảo tính nhất quán giữa bộ nhớ cache và cơ sở dữ liệu. 
						Sử dụng chiến lược này nếu dữ liệu hầu như không thay đổi và trong trường hợp rất
						hiếm còn lại, thì sự không nhất quán đó cũng không phải là vấn đề.
						
Note:						
- Thư viện spring-boot-starter-cache để dùng cache
Ví dụ :
	@Cacheable("user")
    public User findUserById(int id) {
    }
	
    @CacheEvict("user")
    public void clearCacheById(int id) {
    }
	
    @CacheEvict(value = "user", allEntries = true)
    public void clearCache() {
	}
	
	@CachePut(value = "user")
    public User reloadAndFindUserById(int id) {
    }
	

- findUserById  sử dụng annotation @Cacheable("user") tức là kết quả của hàm này sẽ được lưu vào bộ nhớ cache với tên là user
- clearCacheById được đánh dấu annotation @CacheEvict("user") tức là mỗi lần bạn gọi hàm này nó sẽ xóa dữ 
																liệu với id tương ứng ở trong cache user
- clearCache được đánh dấu  @CacheEvict(value = "user", allEntries = true)
											tức là mỗi lần gọi hàm này nó sẽ xóa toàn bộ dữ liệu ở trong cache		
- reloadAndFindUserById được đánh dấu là @CachePut(value = "user")
							tức là dữ liệu trả về sẽ được ghi đè vào cache. Với các method được đánh dấu là @CachePut 
							thì sẽ luôn được thực thi kể cả đã có dữ liệu trong cache hay chưa.											
					
===================================================================================

2.Log4j
Các mức độ / level ghi log: 
- TRACE
- DEBUG
- INFO
- WARN
- ERROR
- FATAL
- OFF

===================================================================================
3.Scheduler

- @Scheduled(fixedDelay : đặc biệt kiểm soát thời gian thực hiện tiếp theo khi 
						  lần thực thi cuối cùng kết thúc.
   VD : fixedDelay = 2000 -> set delay 2 giây giữa những lần xử lý, sync, xử lý xong thì mới bắt đầu tính delay (Sync)

- @Scheduled(fixedRate  : chạy tác vụ theo các khoảng thời gian định kỳ 
						  ngay cả khi lệnh gọi cuối cùng có thể vẫn đang chạy.
   VD : fixedRate = 2000 -> Giống fixedDelay nhưng chạy A-sync
						 	
- @Scheduled(cron 		: Lệnh chạy sẽ được thực thi tại đúng thời điểm thỏa mãn biểu thức crontab
  vd :- @Scheduled(cron = "0 45 23 ? * *")  ->  Chạy vào 23h45' mỗi ngày
	  - @Scheduled(cron = "0 0/5 9 * * ?")  ->  5 phút chạy một lần, bắt đầu từ 09h00 đến 09h55 
											    (ko có đến 10h vì 5' sau cùng của tiếng thứ 9 ko nằm trong giới hạn 9)
												
		"0 0 * * * *"                 the top of every hour of every day.
		"*/10 * * * * *"              every ten seconds.
		"0 0 8-10 * * *"              8, 9 and 10 o'clock of every day.
		"0 0/30 8-10 * * *"           8:00, 8:30, 9:00, 9:30 and 10 o'clock every day.
		"0 0 9-17 * * MON-FRI"        on the hour nine-to-five weekdays
		"0 0 0 25 12 ?"               every Christmas Day at midnight		



		
	